<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Paulinos Spinta â€” Modern</title>
  <!-- Tailwind (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" rel="stylesheet">
  <style>
    :root{--accent:#10b981}
    html,body{height:100%}
    body{font-family:'Inter',system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    .part-img{transition:transform .28s ease,opacity .25s ease}
    .preset-thumb img{transition:transform .18s ease}
    .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}
    .modal-backdrop{z-index:60}
    .mannequin-silhouette{fill:var(--mannequin, #e6e9ee)}
    .dark .mannequin-silhouette{fill: #1f2937}
    input[type=file]{display:none}
  </style>
</head>
<body class="bg-gray-50 dark:bg-gray-900 text-gray-900 dark:text-gray-100 min-h-screen flex flex-col">
  <header class="flex items-center justify-between px-4 py-3 bg-white/60 dark:bg-gray-800/60 backdrop-blur-sm shadow-sm">
    <div class="flex items-center gap-3">
      <div class="text-lg font-semibold">Paulinos Spinta</div>
      <div class="text-xs text-gray-500 dark:text-gray-400">Modern rebuild â€¢ touch friendly</div>
    </div>
    <div class="flex items-center gap-2">
      <button id="exportBtn" class="px-3 py-1 rounded bg-white dark:bg-gray-700 text-sm">Export</button>
      <button id="darkToggle" class="px-3 py-1 rounded bg-gray-100 dark:bg-gray-700 text-sm">Toggle</button>
    </div>
  </header>

  <main class="flex-1 flex flex-col md:flex-row gap-4 p-4 max-w-6xl w-full mx-auto">
    <!-- Left: controls / presets -->
    <aside class="w-full md:w-72 flex-shrink-0 flex flex-col gap-3">
      <div class="rounded-xl bg-white dark:bg-gray-800 p-3 shadow">
        <div class="text-sm font-semibold mb-2">Uploads</div>
        <div class="grid grid-cols-2 gap-2">
          <label class="flex items-center gap-2 py-2 px-3 rounded-lg bg-gray-50 dark:bg-gray-700 cursor-pointer shadow-sm" for="file-head">ðŸ“· <span class="text-sm">Head</span>
            <input id="file-head" type="file" accept="image/*">
          </label>
          <label class="flex items-center gap-2 py-2 px-3 rounded-lg bg-gray-50 dark:bg-gray-700 cursor-pointer shadow-sm" for="file-upper">ðŸ“· <span class="text-sm">Upper</span>
            <input id="file-upper" type="file" accept="image/*">
          </label>
          <label class="flex items-center gap-2 py-2 px-3 rounded-lg bg-gray-50 dark:bg-gray-700 cursor-pointer shadow-sm" for="file-legs">ðŸ“· <span class="text-sm">Legs</span>
            <input id="file-legs" type="file" accept="image/*">
          </label>
          <label class="flex items-center gap-2 py-2 px-3 rounded-lg bg-gray-50 dark:bg-gray-700 cursor-pointer shadow-sm" for="file-feet">ðŸ“· <span class="text-sm">Feet</span>
            <input id="file-feet" type="file" accept="image/*">
          </label>
        </div>
        <p class="text-xs text-gray-500 mt-2">Max 7MB per file. Images saved in browser IndexedDB.</p>
      </div>

      <div class="rounded-xl bg-white dark:bg-gray-800 p-3 shadow flex flex-col gap-2">
        <div class="flex items-center justify-between">
          <div class="text-sm font-semibold">Outfit</div>
          <div class="text-xs text-gray-500">Quick actions</div>
        </div>
        <div class="flex gap-2">
          <button id="randomBtn" class="flex-1 py-2 rounded-md bg-emerald-500 text-white text-sm">ðŸŽ² Random</button>
          <button id="savePreset" class="flex-1 py-2 rounded-md bg-gray-100 dark:bg-gray-700 text-sm">ðŸ’¾ Save</button>
        </div>
        <div class="mt-2">
          <div class="text-xs text-gray-500 mb-1">Presets</div>
          <ul id="presetList" class="flex flex-col gap-2 max-h-56 overflow-auto"></ul>
        </div>
      </div>

      <div class="rounded-xl bg-white dark:bg-gray-800 p-3 shadow">
        <div class="text-sm font-semibold mb-2">Options</div>
        <div class="flex flex-col gap-2">
          <label class="flex items-center gap-2"><input id="darkPref" type="checkbox" class="mr-2">Dark mode</label>
          <label class="flex items-center gap-2"><input id="showContours" type="checkbox" class="mr-2" checked>Show mannequin</label>
        </div>
      </div>
    </aside>

    <!-- Center: mannequin / canvas -->
    <section class="flex-1 flex items-start justify-center">
      <div id="canvas" class="relative w-full max-w-md bg-white dark:bg-gray-800 rounded-xl shadow p-4 overflow-hidden touch-none min-h-[700px] flex flex-col items-center">
        <!-- Mannequin SVG (inline, subtle) -->
        <svg id="mannequinSVG" viewBox="0 0 320 720" class="w-full h-auto mb-2" aria-hidden="true" style="display:block; margin:auto;">
          <defs>
            <linearGradient id="g1" x1="0" x2="1"><stop offset="0" stop-color="#eef2ff"/><stop offset="1" stop-color="#f0fdf4"/></linearGradient>
          </defs>
          <g transform="translate(0,0)">
            <ellipse cx="180" cy="70" rx="48" ry="48" class="mannequin-silhouette" />
            <rect x="70" y="120" width="180" height="130" rx="65" class="mannequin-silhouette" />
            <rect x="68" y="320" width="143" height="230" rx="32" class="mannequin-silhouette" />
            <ellipse cx="147" cy="600" rx="60" ry="35" class="mannequin-silhouette" />
          </g>
        </svg>
        <!-- Parts (absolute positioned inside canvas) -->
        <img id="img-head" class="part-img absolute" alt="head part" hidden>
        <img id="img-upper" class="part-img absolute" alt="upper part" hidden>
        <img id="img-legs" class="part-img absolute" alt="legs part" hidden>
        <img id="img-feet" class="part-img absolute" alt="feet part" hidden>

        <!-- transparent touch buttons for choosing label -->
        <button data-part="head" class="choose-btn absolute" style="z-index:10;">ðŸ‘’</button>
        <button data-part="upper" class="choose-btn absolute" style="z-index:10;">ðŸ‘•</button>
        <button data-part="legs" class="choose-btn absolute" style="z-index:10;">ðŸ‘–</button>
        <button data-part="feet" class="choose-btn absolute" style="z-index:10;">ðŸ‘Ÿ</button>
      </div>
    </section>
  </main>

  <!-- Crop modal (hidden until used) -->
  <div id="cropModal" class="modal-backdrop fixed inset-0 hidden items-center justify-center bg-black/60">
    <div class="bg-white dark:bg-gray-800 rounded-xl p-4 max-w-[92vw] max-h-[86vh] overflow-auto">
      <div class="flex items-center justify-between mb-3">
        <div class="font-semibold">Crop image</div>
        <button id="cropClose" class="px-2 py-1 rounded">âœ•</button>
      </div>
      <div class="max-w-full overflow-auto"><img id="cropImg" src="" alt="crop preview" style="max-width:84vw;max-height:60vh;border-radius:8px;background:#f3f4f6"></div>
      <div class="mt-3 flex gap-2 justify-end">
        <button id="cropSave" class="px-3 py-2 rounded bg-emerald-500 text-white">Save</button>
        <button id="cropCancel" class="px-3 py-2 rounded bg-gray-100 dark:bg-gray-700">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Choose label modal -->
  <div id="labelModal" class="modal-backdrop fixed inset-0 hidden items-center justify-center bg-black/50">
    <div class="bg-white dark:bg-gray-800 rounded-xl p-4 w-full max-w-sm">
      <div class="font-semibold mb-2">Choose label</div>
      <input id="labelInput" class="w-full p-2 rounded border" placeholder="e.g. T-shirt">
      <div class="mt-3 flex gap-2 justify-end">
        <button id="labelSave" class="px-3 py-2 rounded bg-emerald-500 text-white">Save</button>
        <button id="labelClear" class="px-3 py-2 rounded bg-gray-100 dark:bg-gray-700">Clear</button>
      </div>
    </div>
  </div>

  <footer class="text-center text-xs p-3 text-gray-500">Spinta atnaujinta 2025-08-11</footer>

  <!-- Scripts: Cropper, logic -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
  <script>
    // ========== State & PARTS ===========
    // CenterX is the center of the mannequin SVG in px (for 320px SVG)
    const MANNEQUIN_CENTER_X = 160;
    const PARTS = {
      head: { w:80,h:80, shape:'circle', overlap: 8 },
      upper:{ w:180,h:130, shape:'round', overlap: 14 },
      legs:{ w:143,h:230, shape:'round', overlap: 18 },
      feet:{ w:120,h:70, shape:'circle', overlap: 0 }
    };

    let outfit = { head:null, upper:null, legs:null, feet:null };
    let outfitPhotos = { head:null, upper:null, legs:null, feet:null };
    let presets = [];

    const fileEls = {
      head: document.getElementById('file-head'),
      upper: document.getElementById('file-upper'),
      legs: document.getElementById('file-legs'),
      feet: document.getElementById('file-feet')
    };
    const imgEls = {
      head: document.getElementById('img-head'),
      upper: document.getElementById('img-upper'),
      legs: document.getElementById('img-legs'),
      feet: document.getElementById('img-feet')
    };

    // simple IDB wrapper
    const IDB = (()=>{
      const DB='ps-db', STORE='images'; let dbp=null;
      function open(){ if(dbp) return dbp; dbp=new Promise((res,rej)=>{ const r=indexedDB.open(DB,1); r.onupgradeneeded=()=>r.result.createObjectStore(STORE,{keyPath:'id',autoIncrement:true}); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); return dbp; }
      async function add(blob){ const db=await open(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readwrite'); const store=tx.objectStore(STORE); const req=store.add({blob}); req.onsuccess=()=>res(req.result); req.onerror=()=>rej(req.error); }); }
      async function get(id){ if(!id) return null; const db=await open(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readonly'); const store=tx.objectStore(STORE); const req=store.get(id); req.onsuccess=()=>res(req.result?req.result.blob:null); req.onerror=()=>rej(req.error); }); }
      async function del(id){ const db=await open(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readwrite'); const store=tx.objectStore(STORE); const req=store.delete(id); req.onsuccess=()=>res(); req.onerror=()=>rej(req.error); }); }
      return { add, get, del };
    })();

    // ========== Cropper modal ===========
    let cropper=null, currentPart=null;
    const cropModal = document.getElementById('cropModal');
    const cropImg = document.getElementById('cropImg');
    const cropSave = document.getElementById('cropSave');
    const cropCancel = document.getElementById('cropCancel');
    const cropClose = document.getElementById('cropClose');

    function openCrop(dataURL, part){
      currentPart = part;
      cropImg.src = dataURL;
      cropModal.classList.remove('hidden');
      cropModal.classList.add('flex');
      setTimeout(()=>{
        if(cropper) cropper.destroy();
        cropper = new Cropper(cropImg, { aspectRatio: PARTS[part].w / PARTS[part].h, viewMode:1, autoCropArea:1, dragMode:'move', responsive:true });
      },80);
    }
    function closeCrop(){ cropModal.classList.remove('flex'); cropModal.classList.add('hidden'); if(cropper){ cropper.destroy(); cropper=null;} currentPart=null; }

    cropCancel.addEventListener('click', closeCrop); cropClose.addEventListener('click', closeCrop);

    cropSave.addEventListener('click', async ()=>{
      if(!cropper || !currentPart) return;
      const dims = PARTS[currentPart];
      const canvas = cropper.getCroppedCanvas({ width: dims.w*2, height: dims.h*2 });
      canvas.toBlob(async (blob)=>{
        const id = await IDB.add(blob);
        outfitPhotos[currentPart] = id; persistState(); await renderPhotos(); closeCrop();
      }, 'image/png', 0.92);
    });

    // ========== File inputs ===========
    Object.entries(fileEls).forEach(([part,el])=>{
      el.addEventListener('change', ()=>{ const f = el.files && el.files[0]; if(!f) return; if(!f.type.startsWith('image/')){ alert('Choose an image'); return; } if(f.size > 7*1024*1024){ alert('Max size 7MB'); return; } const r = new FileReader(); r.onload=()=> openCrop(r.result, part); r.readAsDataURL(f); });
    });

    // ========== render photos and stack them, with centering ==========
    async function renderPhotos(){
      // First, get all blobs and dimensions
      let images = {};
      for(const part of Object.keys(PARTS)){
        const id = outfitPhotos[part]; const img = imgEls[part];
        if(id){
          const blob = await IDB.get(id); 
          if(blob){
            const url = URL.createObjectURL(blob);
            images[part] = { url, img, meta: PARTS[part] };
            img.src=url; img.hidden=false;
            img.onload=()=>{ URL.revokeObjectURL(url); placeStackedParts(); };
          } else { img.hidden=true; }
        } else { img.hidden=true; }
      }
      // After all images, call placement
      placeStackedParts();
      renderLabels();
    }

    // Stack placement: each part connects to the previous and the skeleton is centered
    function placeStackedParts(){
      const canvasEl = document.getElementById('canvas');
      const bw = canvasEl.clientWidth;
      const scale = bw / 320;
      const order = ['head','upper','legs','feet'];
      let top = 32 * scale;
      const imgRects = {};
      // First pass: compute sizes for each part
      for(const part of order){
        const img = imgEls[part];
        const meta = PARTS[part];
        const w = meta.w * scale;
        const h = meta.h * scale;
        img.style.width = w+'px'; img.style.height = h+'px';
        img.style.borderRadius = meta.shape==='circle'? '9999px': '12px';
        img.style.position = 'absolute';
        imgRects[part] = {w, h, meta};
      }
      // Second pass: vertical stacking
      let y = top;
      for(let i = 0; i < order.length; ++i){
        const part = order[i];
        const img = imgEls[part];
        const {w, h, meta} = imgRects[part];
        if(img.hidden) continue;
        if(part === 'head' && !imgEls.upper.hidden){
          // Center head horizontally on upper, put base of head flush to upper's top
          const upper = imgEls.upper;
          img.style.left = (upper.offsetLeft + (upper.width - w)/2) + 'px';
          img.style.top = (upper.offsetTop - h + PARTS[part].overlap) + 'px';
        } else if (part === 'upper' && !imgEls.head.hidden){
          // Center upper on canvas (for initial alignment)
          img.style.left = ((bw - w) / 2) + 'px';
          img.style.top = y + 'px';
        } else if(i > 0){
          // Connect this part to the previous visible part
          let prevIdx = i-1;
          while(prevIdx >= 0 && imgEls[order[prevIdx]].hidden) prevIdx--;
          if(prevIdx >= 0){
            const prev = imgEls[order[prevIdx]];
            img.style.left = (prev.offsetLeft + (prev.width - w)/2) + 'px';
            img.style.top = (prev.offsetTop + prev.height - PARTS[order[prevIdx]].overlap) + 'px';
          } else {
            img.style.left = ((bw - w) / 2) + 'px';
            img.style.top = y + 'px';
          }
        } else {
          // If first part and not head, center horizontally
          img.style.left = ((bw - w) / 2) + 'px';
          img.style.top = y + 'px';
        }
      }
      // Center the whole figure horizontally as a group
      // Find min/max left/right of all visible images
      let minLeft = Infinity, maxRight = -Infinity;
      order.forEach(part=>{
        const img = imgEls[part];
        if(!img.hidden){
          const l = parseFloat(img.style.left); const r = l + img.width;
          if(l < minLeft) minLeft = l;
          if(r > maxRight) maxRight = r;
        }
      });
      if(minLeft < Infinity && maxRight > -Infinity){
        const groupWidth = maxRight - minLeft;
        const canvasWidth = canvasEl.clientWidth;
        const shift = (canvasWidth - groupWidth) / 2 - minLeft;
        order.forEach(part=>{
          const img = imgEls[part];
          if(!img.hidden){
            img.style.left = (parseFloat(img.style.left) + shift) + 'px';
          }
        });
      }
      // Place choose buttons where parts are
      for(const part of order){
        const btn = document.querySelector(`button.choose-btn[data-part="${part}"]`);
        const img = imgEls[part];
        if(btn && img && !img.hidden){
          const bwid = Math.max(36, Math.min(80, img.width*0.28));
          const bht = Math.max(28, Math.min(48, img.height*0.18));
          btn.style.left = (img.offsetLeft + (img.width-bwid)/2) + 'px';
          btn.style.top = (img.offsetTop + (img.height-bht)/2) + 'px';
          btn.style.width = bwid + 'px';
          btn.style.height = bht + 'px';
          btn.style.borderRadius = PARTS[part].shape==='circle' ? '9999px' : '8px';
          btn.hidden = false;
        } else if(btn) {
          btn.hidden = true;
        }
      }
    }

    window.addEventListener('resize', ()=>{ placeStackedParts(); });

    // ========== label modal ===========
    const labelModal = document.getElementById('labelModal');
    const labelInput = document.getElementById('labelInput');
    const labelSave = document.getElementById('labelSave');
    const labelClear = document.getElementById('labelClear');
    let labelFor = null;

    document.querySelectorAll('.choose-btn').forEach(b=> b.addEventListener('click', (e)=>{ labelFor = e.currentTarget.dataset.part; labelModal.classList.remove('hidden'); labelModal.classList.add('flex'); labelInput.value = outfit[labelFor] || ''; setTimeout(()=>labelInput.focus(),60); }));

    labelSave.addEventListener('click', ()=>{ if(!labelFor) return; const v = labelInput.value.trim(); outfit[labelFor] = v || null; persistState(); renderLabels(); labelModal.classList.remove('flex'); labelModal.classList.add('hidden'); });
    labelClear.addEventListener('click', ()=>{ if(!labelFor) return; outfit[labelFor] = null; persistState(); renderLabels(); labelModal.classList.remove('flex'); labelModal.classList.add('hidden'); });

    function renderLabels(){ document.querySelectorAll('.js-label').forEach(n=>n.remove()); const canvasEl = document.getElementById('canvas'); const scale = canvasEl.clientWidth / 320; for(const [part,val] of Object.entries(outfit)){ if(!val) continue; const img = imgEls[part]; if(img && !img.hidden){ const span = document.createElement('div'); span.className='js-label absolute px-3 py-1 rounded-full bg-gray-900/90 dark:bg-gray-800/90 text-sm font-semibold shadow-md text-white'; span.textContent = val; canvasEl.appendChild(span); const top = img.offsetTop + img.height + 4; span.style.top = top+'px'; span.style.left = (img.offsetLeft + img.width/2 - span.offsetWidth/2) + 'px'; } }
    }

    // ========== preset handling ===========
    const presetList = document.getElementById('presetList');
    document.getElementById('savePreset').addEventListener('click', saveCurrentPreset);
    document.getElementById('randomBtn').addEventListener('click', ()=>{ for(const p of Object.keys(outfit)){ const opts = {head:['Cap','Hat','Bandana','None'], upper:['T-shirt','Jacket','Dress','Sweater','Shirt'], legs:['Jeans','Skirt','Shorts','Trousers'], feet:['Sneakers','Boots','Sandals','Dress shoes'] }[p]; outfit[p] = opts[Math.floor(Math.random()*opts.length)]; } persistState(); renderLabels(); });

    async function saveCurrentPreset(){ const name = prompt('Preset name'); if(!name) return; // build thumbnail
      const cw=160,ch=360; const c=document.createElement('canvas'); c.width=cw; c.height=ch; const ctx=c.getContext('2d'); ctx.fillStyle='#fff'; ctx.fillRect(0,0,cw,ch); for(const part of ['head','upper','legs','feet']){ const id = outfitPhotos[part]; if(!id) continue; const blob = await IDB.get(id); if(!blob) continue; const img = await blobToImage(blob); const ref = PARTS[part]; const scale = cw/320; ctx.drawImage(img, (MANNEQUIN_CENTER_X-ref.w/2)*scale, ref.overlap?ref.overlap*scale:0, ref.w*scale, ref.h*scale); }
      const thumb = c.toDataURL('image/png'); const entry = { name, outfit:{...outfit}, photos:{...outfitPhotos}, thumb, created: Date.now() }; presets.unshift(entry); persistPresets(); alert('Saved'); }

    function renderPresets(){ presetList.innerHTML=''; presets.forEach((p,idx)=>{ const li=document.createElement('li'); li.className='flex items-center gap-2 p-2 rounded-md bg-gray-50 dark:bg-gray-700'; li.innerHTML = `<div class="w-12 h-28 overflow-hidden rounded-md"><img src="${p.thumb}" class="w-full h-full object-cover"/></div><div class="flex-1 text-sm">${p.name}</div>`; const btns = document.createElement('div'); btns.className='flex gap-1'; const load=document.createElement('button'); load.textContent='Load'; load.className='px-2 py-1 rounded bg-emerald-500 text-white text-sm'; load.addEventListener('click', ()=>{ outfit = {...p.outfit}; outfitPhotos = {...p.photos}; persistState(); renderLabels(); renderPhotos(); }); const del=document.createElement('button'); del.textContent='Del'; del.className='px-2 py-1 rounded bg-gray-100 dark:bg-gray-700 text-sm'; del.addEventListener('click', ()=>{ if(confirm('Delete preset?')){ presets.splice(idx,1); persistPresets(); }}); btns.append(load,del); li.appendChild(btns); presetList.appendChild(li); }); }

    function persistPresets(){ localStorage.setItem('ps_presets', JSON.stringify(presets)); renderPresets(); }
    function loadPresets(){ try{ presets = JSON.parse(localStorage.getItem('ps_presets')||'[]'); }catch(e){ presets=[] } renderPresets(); }

    function persistState(){ localStorage.setItem('ps_outfit', JSON.stringify(outfit)); localStorage.setItem('ps_photos', JSON.stringify(outfitPhotos)); }
    async function loadState(){ try{ outfit = JSON.parse(localStorage.getItem('ps_outfit')) || outfit; outfitPhotos = JSON.parse(localStorage.getItem('ps_photos')) || outfitPhotos; }catch(e){} await renderPhotos(); renderLabels(); }

    function blobToImage(blob){ return new Promise(res=>{ const url = URL.createObjectURL(blob); const img = new Image(); img.onload = ()=>{ URL.revokeObjectURL(url); res(img); }; img.src = url; }); }

    // ========== export/import (basic) ==========
    document.getElementById('exportBtn').addEventListener('click', async ()=>{
      const payload = { outfit, presets, photos: {} };
      for(const p of Object.values(outfitPhotos)){ if(!p) continue; const b = await IDB.get(p); payload.photos[p] = await blobToBase64(b); }
      const blob = new Blob([JSON.stringify(payload)], {type:'application/json'});
      const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download='paulinos-spinta-export.json'; document.body.appendChild(a); a.click(); URL.revokeObjectURL(url); a.remove();
    });
    function blobToBase64(blob){ return new Promise(res=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.readAsDataURL(blob); }); }

    // ========== init ==========
    loadPresets(); loadState();
    setTimeout(()=>{ placeStackedParts(); renderPhotos(); },200);

    // dark toggle and preferences
    const darkToggle = document.getElementById('darkToggle'); const darkPref = document.getElementById('darkPref');
    function applyPref(){ const p = localStorage.getItem('theme') || 'dark'; if(p==='dark'){ document.documentElement.classList.add('dark'); darkPref.checked=true } else { document.documentElement.classList.remove('dark'); darkPref.checked=false; } }
    darkToggle.addEventListener('click', ()=>{ const now = document.documentElement.classList.toggle('dark'); localStorage.setItem('theme', now ? 'dark' : 'light'); applyPref(); }); darkPref.addEventListener('change', ()=>{ localStorage.setItem('theme', darkPref.checked ? 'dark' : 'light'); applyPref(); }); applyPref();

    // show/hide mannequin
    document.getElementById('showContours').addEventListener('change', (e)=> document.getElementById('mannequinSVG').style.opacity = e.target.checked ? '1' : '0.08');
  </script>
</body>
</html>